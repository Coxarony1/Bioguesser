<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bioguesser – Habitat & Verbreitungsgebiete</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body{margin:0;font-family:Inter,Arial;background:#0c111b;color:#e8eef5}
    .app{display:grid;grid-template-columns:340px 1fr;height:100vh;overflow-x:hidden}
    .app.collapsed{grid-template-columns:0 1fr}
    .sidebar{
      padding:18px;
      background:#111827;
      position:relative;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      justify-content:flex-start;
      overflow:hidden; /* avoid scrollbars; content is responsive */
      height:100vh;
    }
    .mapwrap{position:relative}
    #map{height:100%;width:100%}

    .btn{
      padding:clamp(6px,1.2vh,10px) clamp(8px,1.6vw,12px);
      border:none;
      border-radius:6px;
      cursor:pointer;
      font-size:clamp(0.82rem,1.6vw,1rem);
    }
    .btn.primary{background:#22c55e;color:#062712}

    .img-wrap{width:100%;max-height:calc(100vh - 260px);overflow:hidden;border-radius:8px;margin-bottom:10px}
    #animalImg{width:100%;height:100%;object-fit:cover;object-position:top center;display:block}

    /* Responsive text & controls to avoid vertical/horizontal scrolling */
    #animalName{font-size:clamp(1.05rem,2.2vw,1.25rem);margin:8px 0 4px}
    #animalLatname{font-size:clamp(0.9rem,1.6vw,1rem);color:#9ca3af;margin:0 0 8px}
    #habitatButtons, #taxonButtons{display:flex;flex-wrap:wrap;gap:6px}
    #resultBox{font-size:clamp(0.9rem,1.6vw,1rem)}
    #infoCard{font-size:clamp(0.85rem,1.5vw,0.98rem)}
    label{font-size:clamp(0.92rem,1.8vw,1rem)}
    #infoCard{background:#1e293b;border-radius:8px;padding:12px;margin-top:12px}
    #infoCard h3{margin:0 0 8px 0}
    #infoCard p{margin:4px 0}

    /* Auswahlzustände der Buttons */
    .habitat-btn,
    .taxon-btn{
      background:#1e293b;
      color:#e5e7eb;
      margin-bottom:4px;
    }
    .habitat-btn.selected,
    .taxon-btn.selected{
      background:#38bdf8;
      color:#0f172a;
    }
    .btn-correct{
      background:#22c55e !important;
      color:#052e16 !important;
    }
    .btn-wrong{
      background:#ef4444 !important;
      color:#fef2f2 !important;
    }

    /* Gesamtpunkte unten links in der Sidebar */
    #totalScoreBox{
      position:absolute;
      top:12px;
      right:18px;
      font-size:1.425rem;
      color:#e5e7eb;
      padding:9px 15px;
      background:#020617;
      border-radius:999px;
      border:2px solid #7f1d1d;
      z-index:600;
      box-shadow:0 6px 18px rgba(0,0,0,0.55);
    }

    /* Nächste-Runde-Button: zentral in der Karte, groß; zunächst unsichtbar */
    #nextBtn{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      padding:16px 32px;
      font-size:1.2rem;
      border-radius:999px;
      background:#0ea5e9;
      color:#0f172a;
      border:none;
      cursor:pointer;
      font-weight:700;
      box-shadow:0 12px 36px rgba(15,23,42,0.9);
      z-index:500;
      display:none;
    }
    #nextBtn:hover{
      background:#0284c7;
    }

    /* Sidebar toggle button (border between sidebar and map) */
    #sidebarToggle{
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      right:-20px; /* attach to right edge of sidebar (half of width) */
      width:40px; /* doubled width */
      height:52px;
      border-radius:8px;
      background:#1f2937;
      color:#e5e7eb;
      border:2px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:900;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
      font-size:16px;
      padding:0;
    }
    .app.collapsed #sidebarToggle{ left:0; right:auto; }
    /* When the sidebar is visible, push the arrow to the far left of the toggle for visibility */
    .app:not(.collapsed) #sidebarToggle{ justify-content:flex-start; padding-left:6px; }

    /* --------- STARTSEITE / LANDING PAGE --------- */
    #startScreen{
      position:fixed;
      inset:0;
      background:radial-gradient(circle at top, #064e3b 0, #020617 55%, #000 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:20px;
    }
    .start-inner{
      max-width:720px;
      text-align:center;
      background:rgba(15,23,42,0.9);
      border-radius:18px;
      padding:32px 26px 28px;
      box-shadow:0 25px 60px rgba(0,0,0,0.6);
      border:1px solid rgba(34,197,94,0.4);
    }
    .start-title{
      font-size:3rem;
      font-weight:800;
      margin:0 0 16px;
      color:#22c55e;
      letter-spacing:0.08em;
      text-transform:uppercase;
    }
    .start-subtitle{
      font-size:1.15rem;
      margin:0 0 18px;
      color:#cbd5e1;
      font-weight:500;
    }
    .start-text{
      text-align:left;
      line-height:1.5;
      font-size:0.98rem;
      color:#e5e7eb;
      margin:0 auto 22px;
      max-width:640px;
    }
    .start-text b{color:#bbf7d0;}
    .start-points{
      margin:14px auto 18px;
      max-width:460px;
      font-size:0.96rem;
    }
    .start-points ul{
      padding-left:18px;
      margin:6px 0 0;
    }
    .start-points li{
      margin:3px 0;
    }
    .start-footer{
      font-size:0.9rem;
      color:#9ca3af;
      margin-top:10px;
    }
    .start-names{
      color:#e5e7eb;
      font-weight:500;
    }
    #startGameBtn{
      margin-top:6px;
      padding:11px 26px;
      font-size:1.05rem;
      border-radius:999px;
      background:#22c55e;
      color:#052e16;
      border:none;
      cursor:pointer;
      font-weight:700;
      box-shadow:0 12px 35px rgba(34,197,94,0.35);
      transition:transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }
    #startGameBtn:hover{
      background:#16a34a;
      transform:translateY(-1px);
      box-shadow:0 16px 45px rgba(34,197,94,0.45);
    }
    #startGameBtn:active{
      transform:translateY(0);
      box-shadow:0 8px 24px rgba(34,197,94,0.3);
    }

    @media (max-width:800px){
      .start-inner{
        padding:24px 20px 22px;
      }
      .start-title{
        font-size:2.3rem;
      }
      .start-text{
        font-size:0.95rem;
      }
    }
  </style>
</head>
<body>

<!-- STARTSEITE -->
<div id="startScreen">
  <div class="start-inner">
    <h1 class="start-title">BioGuesser</h1>
    <p class="start-subtitle">
      Entdeckt Tiere, Lebensräume und ihre Verbreitung auf unserer Erde!
    </p>

    <p class="start-text">
      Im Spiel <b>BioGuesser</b> geht es darum, die unterschiedlichsten Tierarten und
      ihre Verbreitung auf der Welt kennenzulernen. Eure Aufgabe ist es außerdem,
      die <b>Habitate</b> sowie eine sehr vereinfachte <b>taxonomische Einordnung</b>
      der Tiere zuzuordnen.
    </p>

    <div class="start-points">
      <p><b>So funktioniert’s:</b></p>
      <ul>
        <li>Links seht ihr ein Tier mit Bild und Namen.</li>
        <li>Ihr klickt auf der Weltkarte dorthin, wo ihr glaubt, dass dieses Tier lebt.</li>
        <li>Unter dem Tier wählt ihr das passende <b>Habitat</b> und die richtige <b>Taxonomie</b> aus.</li>
      </ul>
    </div>

    <div class="start-points">
      <p><b>Punkte sammeln:</b></p>
      <ul>
        <li>Trefft ihr den Bereich des Lebensraums korrekt: <b>+1000 Punkte</b></li>
        <li>Seid ihr bis 100km daneben: <b>+500 Punkte</b></li>
        <li>Seid ihr bis 500km daneben: <b>+200 Punkte</b></li>
        <li>Seid ihr bis 1000km daneben: <b>+50 Punkte</b></li>
        <li>Richtige taxonomische Einordnung: <b>+200 Punkte</b></li>
        <li>Richtige Habitat-Zuordnung: <b>+200 Punkte</b></li>
      </ul>
      <p style="margin-top:6px;">
        Sammelt so viele Punkte wie möglich, um auf der Rangliste aufzusteigen!
      </p>
    </div>

    <button id="startGameBtn">Starte das Spiel</button>

    <p class="start-footer">
      Viel Spaß beim Spielen und Lernen wünschen euch<br>
      <span class="start-names">Lilly, Henriette, Joscha, Joshi, Konrad und Luca</span>.
    </p>
  </div>
</div>

<div class="app">

  <!-- Sidebar -->
  <div class="sidebar">

    <div class="img-wrap">
      <img id="animalImg" src="" alt="Tier">
    </div>

    <h2 id="animalName"></h2>
    <p><i id="animalLatname"></i></p>

    <div>
      <label>Wähle Habitat:</label>
      <div id="habitatButtons"></div>
    </div>

    <div style="margin-top:10px;">
      <label>Wähle taxonomische Einordnung:</label>
      <div id="taxonButtons"></div>
    </div>

    <div style="margin-top:10px;">
      <button id="submitBtn" class="btn primary">Raten</button>
    </div>

    <div id="resultBox" style="margin-top:12px"></div>

    <div id="infoCard" style="display:none"></div>
    <button id="sidebarToggle" title="Verstecken/Anzeigen">◀</button>
  </div>

  <!-- Map -->
  <div class="mapwrap">
    <button id="nextBtn" class="btn">Nächste Runde</button>
    <div id="map"></div>
    <div id="totalScoreBox">Gesamtpunkte: 0</div>
  </div>

</div>

<!-- Scripts -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script>
// ==========================
// MAP
// ==========================
const map = L.map('map').setView([20,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

// ==========================
// STARTSEITE: Overlay ausblenden + Karte neu berechnen
// ==========================
document.addEventListener('DOMContentLoaded', () => {
  const startBtn = document.getElementById('startGameBtn');
  if(startBtn){
    startBtn.addEventListener('click', () => {
      const startScreen = document.getElementById('startScreen');
      if(startScreen){
        startScreen.style.display = 'none';
      }
      // New game: reset shown cards and pick first random animal
      shownIndices.clear();
      currentIndex = pickRandomIndex();
      setTimeout(() => {
        map.invalidateSize();
        map.setView([20, 0], 2);
        loadRound();
      }, 100);
    });
  }
});

// ==========================
// HABITAT & VERBREITUNGSPOLYGONE
// ==========================
const HABITAT_POLYGONS = {};
const RANGE_POLYGONS = {};

// ==========================
// TIERE & Infodateien
// ==========================
let ANIMALS = [];

async function loadAnimalsFromJSON(){
  try{
    const res = await fetch('animals/Tierinfos.json');
    const data = await res.json();
    ANIMALS = Object.values(data);

    ANIMALS.forEach(a => {
      if(a && a.name && a.distribution){
        RANGE_POLYGONS[a.name] = a.distribution;
      }
    });
  }catch(e){
    console.error('Fehler beim Laden der Tierinformationen:', e);
  }
}

let round = 0;
let selectedHabitat = null;
let selectedTaxon = null;
let selectedLatLng = null;
let marker = null;
let lastRangeLayer = null;
let lastDistanceLayer = null;
let totalScore = 0;
let shownIndices = new Set();
let currentIndex = null;

// ==========================
// Punkte-Anzeige
// ==========================
function updateTotalScore(){
  const box = document.getElementById('totalScoreBox');
  if(box){
    box.textContent = `Gesamtpunkte: ${totalScore}`;
  }
}

// ==========================
// SPIEL
// ==========================
function resetButtonStates(){
  document.querySelectorAll('.habitat-btn, .taxon-btn').forEach(b=>{
    b.classList.remove('selected','btn-correct','btn-wrong');
  });
}

function pickRandomIndex(){
  if(!ANIMALS || ANIMALS.length === 0) return -1;
  if(shownIndices.size >= ANIMALS.length) return -1;
  const remaining = [];
  for(let i=0;i<ANIMALS.length;i++) if(!shownIndices.has(i)) remaining.push(i);
  const idx = remaining[Math.floor(Math.random()*remaining.length)];
  shownIndices.add(idx);
  return idx;
}

function loadRound(){
  if(currentIndex === null){
    currentIndex = pickRandomIndex();
  }
  if(currentIndex === -1 || currentIndex === null){
    alert('Alle Karten wurden gezeigt. Das Spiel ist beendet.');
    return;
  }
  const a = ANIMALS[currentIndex];
  document.getElementById('animalImg').src = a.image || '';
  document.getElementById('animalName').textContent = a.name || '';
  document.getElementById('animalLatname').textContent = a.latin || '';

  // Ensure sidebar scrolls to bottom so buttons are visible when image is large
  const sidebarEl = document.querySelector('.sidebar');
  const imgEl = document.getElementById('animalImg');
  if(sidebarEl && imgEl){
    imgEl.onload = () => { sidebarEl.scrollTop = sidebarEl.scrollHeight; };
    // If image already loaded from cache, scroll immediately
    if(imgEl.complete) sidebarEl.scrollTop = sidebarEl.scrollHeight;
  }

  selectedHabitat = null;
  selectedTaxon = null;
  resetButtonStates();

  selectedLatLng = null;
  if(marker) map.removeLayer(marker);
  if(lastRangeLayer){ map.removeLayer(lastRangeLayer); lastRangeLayer = null; }
  if(lastDistanceLayer){ map.removeLayer(lastDistanceLayer); lastDistanceLayer = null; }
  document.getElementById('infoCard').style.display = 'none';
  document.getElementById('resultBox').innerHTML = '';

  // Nächste-Runde-Button verbergen, falls von vorher noch sichtbar
  const nextBtn = document.getElementById('nextBtn');
  if(nextBtn) nextBtn.style.display = 'none';
}

function selectHabitat(h){
  selectedHabitat = h;
  document.querySelectorAll('.habitat-btn').forEach(b=>b.classList.remove('selected','btn-correct','btn-wrong'));
  const btn = document.getElementById('hab-'+h);
  if(btn) btn.classList.add('selected');
}

function selectTaxon(t){
  selectedTaxon = t;
  document.querySelectorAll('.taxon-btn').forEach(b=>b.classList.remove('selected','btn-correct','btn-wrong'));
  const btn = document.getElementById('tax-'+t);
  if(btn) btn.classList.add('selected');
}

// Habitat Buttons
const habitatList = ['Savanne','Wüste','Wald','Tundra','Grasland','Ozean','Feuchtgebiet'];
const habEl = document.getElementById('habitatButtons');
habitatList.forEach(h=>{
  const b = document.createElement('button');
  b.id = 'hab-'+h;
  b.textContent = h;
  b.className = 'btn habitat-btn';
  b.style.marginRight = '5px';
  b.onclick = ()=> selectHabitat(h);
  habEl.appendChild(b);
});

// Taxonomie-Buttons
const taxonList = ['Säugetiere','Amphibien','Reptilien','Vögel','Fische','Gliederfüßer','Weichtiere'];
const taxEl = document.getElementById('taxonButtons');
taxonList.forEach(t=>{
  const b = document.createElement('button');
  b.id = 'tax-'+t;
  b.textContent = t;
  b.className = 'btn taxon-btn';
  b.style.marginRight = '5px';
  b.onclick = ()=> selectTaxon(t);
  taxEl.appendChild(b);
});

// Kartenklick
map.on('click', e =>{
  selectedLatLng = e.latlng;
  if(marker) map.removeLayer(marker);
  marker = L.marker(selectedLatLng).addTo(map);
});

// ==========================
// DISTANZLOGIK
// ==========================
function distanceToPolygon(point, polygon){
  // Normalize and compute distance via closest point helper so we support
  // Feature, Geometry and FeatureCollection inputs.
  const closest = closestPointOnPolygon(point, polygon);
  return closest.distance;
}

// Returns true if point is inside any polygon/feature. Supports FeatureCollection.
function pointInPolygonAny(point, polygon){
  if(!polygon) return false;
  if(polygon.type === 'FeatureCollection'){
    return polygon.features.some(f => turf.booleanPointInPolygon(point, f));
  }
  // For Feature or Geometry
  return turf.booleanPointInPolygon(point, polygon);
}

// Find closest point on a Polygon or MultiPolygon to `point` (both GeoJSON features)
function closestPointOnPolygon(point, polygon){
  // Accept Feature, Geometry or FeatureCollection
  if(!polygon) return {distance: Infinity, coord: null};

  if(polygon.type === 'FeatureCollection'){
    let best = {distance: Infinity, coord: null};
    polygon.features.forEach(f => {
      const c = closestPointOnPolygon(point, f);
      if(c.distance < best.distance){ best = c; }
    });
    return best;
  }

  let geom = polygon.type === 'Feature' ? polygon.geometry : polygon;
  let minDist = Infinity;
  let nearestCoord = null;

  function checkCoords(coords){
    // coords is an array of positions making a linear ring or linestring
    try{
      const line = turf.lineString(coords);
      const nearest = turf.nearestPointOnLine(line, point);
      const d = turf.distance(point, nearest, {units:'kilometers'});
      if(d < minDist){ minDist = d; nearestCoord = nearest.geometry.coordinates; }
    }catch(e){ /* ignore malformed rings */ }
  }

  if(!geom) return {distance: Infinity, coord: null};
  if(geom.type === 'Polygon'){
    geom.coordinates.forEach(ring => checkCoords(ring));
  } else if(geom.type === 'MultiPolygon'){
    geom.coordinates.forEach(p => p.forEach(ring => checkCoords(ring)));
  }

  return { distance: minDist, coord: nearestCoord };
}

// ==========================
// RATEN
// ==========================
async function submitGuess(){
  const a = ANIMALS[currentIndex];
  if(!selectedLatLng){ alert('Bitte auf die Karte klicken!'); return; }
  if(!selectedHabitat){ alert('Bitte Habitat wählen!'); return; }
  if(!selectedTaxon){ alert('Bitte taxonomische Einordnung wählen!'); return; }

  const pt = turf.point([selectedLatLng.lng, selectedLatLng.lat]);

  const habitatPoly = HABITAT_POLYGONS[a.habitat];
  const rangePoly = RANGE_POLYGONS[a.name];
  let points = 0;

  // Habitat-Punkte
  if(selectedHabitat === a.habitat) points += 200;

  // Taxonomie-Punkte
  if(selectedTaxon === a.taxon) points += 200;

  // Entfernung zu Habitat-Polygon (falls später vorhanden)
  if(habitatPoly){
    const d = distanceToPolygon(pt, habitatPoly);
    if(d < 2000) points += Math.round((2000 - d) / 2000 * 300);
  }

  // Verbreitungsgebiet: inside -> +1000, otherwise compute distance and award by bands.
  let rangeDistanceKm = null;
  let nearestCoord = null;
  let insideRange = false;
  let rangePoints = 0;
  if(rangePoly){
    try{
      insideRange = pointInPolygonAny(pt, rangePoly);
      if(insideRange){
        rangePoints = 1000;
      } else {
        const closest = closestPointOnPolygon(pt, rangePoly);
        rangeDistanceKm = closest.distance;
        nearestCoord = closest.coord; // [lng, lat]

        if(rangeDistanceKm !== null && isFinite(rangeDistanceKm)){
          if(rangeDistanceKm <= 100) rangePoints = 500;
          else if(rangeDistanceKm <= 500) rangePoints = 200;
          else if(rangeDistanceKm <= 1000) rangePoints = 50;
        }
      }
    }catch(e){
      console.warn('Fehler beim Prüfen des Verbreitungsgebiets:', e);
    }
  } else {
    console.log(`Kein Verbreitungsgebiet für ${a.name} gefunden.`);
  }

  // Apply range points to total points for this round
  points += rangePoints;

  // Buttons farblich bewerten
  // Habitat
  const selectedHabBtn = document.getElementById('hab-'+selectedHabitat);
  const correctHabBtn  = document.getElementById('hab-'+a.habitat);
  if(selectedHabBtn) selectedHabBtn.classList.remove('selected','btn-correct','btn-wrong');
  if(correctHabBtn) correctHabBtn.classList.remove('selected','btn-correct','btn-wrong');

  if(selectedHabitat === a.habitat){
    if(selectedHabBtn) selectedHabBtn.classList.add('btn-correct');
  }else{
    if(selectedHabBtn) selectedHabBtn.classList.add('btn-wrong');
    if(correctHabBtn) correctHabBtn.classList.add('btn-correct');
  }

  // Taxon
  const selectedTaxBtn = document.getElementById('tax-'+selectedTaxon);
  const correctTaxBtn  = document.getElementById('tax-'+a.taxon);
  if(selectedTaxBtn) selectedTaxBtn.classList.remove('selected','btn-correct','btn-wrong');
  if(correctTaxBtn) correctTaxBtn.classList.remove('selected','btn-correct','btn-wrong');

  if(selectedTaxon === a.taxon){
    if(selectedTaxBtn) selectedTaxBtn.classList.add('btn-correct');
  }else{
    if(selectedTaxBtn) selectedTaxBtn.classList.add('btn-wrong');
    if(correctTaxBtn) correctTaxBtn.classList.add('btn-correct');
  }

  // Verbreitungsgebiet hervorheben
  try{
    if(lastRangeLayer){ map.removeLayer(lastRangeLayer); lastRangeLayer = null; }
    if(lastDistanceLayer){ map.removeLayer(lastDistanceLayer); lastDistanceLayer = null; }
    if(rangePoly){
      const highlightStyle = { color:'#22c55e', weight:3, fillColor:'#22c55e', fillOpacity:0.15 };
      lastRangeLayer = L.geoJSON(rangePoly, { style: highlightStyle }).addTo(map);
      if(lastRangeLayer.bringToFront) lastRangeLayer.bringToFront();

      // If click was outside, draw a line to nearest polygon point and show distance
      if(!insideRange && nearestCoord){
        const nearestLatLng = [nearestCoord[1], nearestCoord[0]];
        const line = L.polyline([
          [selectedLatLng.lat, selectedLatLng.lng],
          nearestLatLng
        ], { color: '#f59e0b', weight: 2, dashArray: '6,6' });

        // small marker at nearest point
        const nearestMarker = L.circleMarker(nearestLatLng, { radius:5, color:'#f59e0b', fillColor:'#f59e0b' });

        lastDistanceLayer = L.layerGroup([line, nearestMarker]).addTo(map);

        const distText = (rangeDistanceKm !== null && isFinite(rangeDistanceKm)) ? `${rangeDistanceKm.toFixed(1).replace('.',',')} km` : 'unbekannt';
        let pointsText = '';
        if(rangePoints){
          pointsText = `: +${rangePoints} Punkte`;
        } else if(rangeDistanceKm !== null && isFinite(rangeDistanceKm) && rangeDistanceKm > 1000){
          pointsText = ': Keine Punkte';
        }
        if(marker){
          marker.bindPopup(`<b>Entfernung zum Verbreitungsgebiet:</b> ${distText}${pointsText}`).openPopup();
        }
      } else if(insideRange){
        if(marker) marker.bindPopup(`<b>Richtig!</b> In Verbreitungsgebiet (+${rangePoints} Punkte)`).openPopup();
      }
    }
  }catch(e){ console.warn('Fehler beim Hervorheben des Verbreitungsgebiets:', e); }

  // Punkte anzeigen und Gesamtpunkte erhöhen
  let distInfo = '';
  if(rangeDistanceKm !== null && isFinite(rangeDistanceKm) && !insideRange){
    distInfo = `<br><b>Entfernung:</b> ${rangeDistanceKm.toFixed(1)} km`;
  }
  document.getElementById('resultBox').innerHTML = `<b>Punkte dieser Runde:</b> ${points}${distInfo}`;
  totalScore += points;
  updateTotalScore();

  // Infokarte laden (falls infoFile im JSON vorhanden ist)
  if(a.infoFile){
    loadInfo(a.infoFile);
  }

  // Nächste-Runde-Button einblenden
  const nextBtn = document.getElementById('nextBtn');
  if(nextBtn) nextBtn.style.display = 'inline-block';
}

document.getElementById('submitBtn').onclick = submitGuess;

// ==========================
// NÄCHSTE RUNDE
// ==========================
document.getElementById('nextBtn').onclick = () => {
  const idx = pickRandomIndex();
  if(idx === -1){
    alert('Alle Karten wurden gezeigt. Das Spiel ist beendet.');
    document.getElementById('nextBtn').style.display = 'none';
    return;
  }
  currentIndex = idx;
  loadRound();
};

// ==========================
// INFO LADEN
// ==========================
async function loadInfo(file){
  try{
    const res = await fetch(file);
    const data = await res.json();
    const box = document.getElementById('infoCard');

    box.innerHTML = `
      <h3>${data.title}</h3>
      <p>${data.text}</p>
    `;
    box.style.display = 'block';
  }catch(e){ console.error('Info konnte nicht geladen werden:',e); }
}

// Start
loadAnimalsFromJSON().then(() => {
  // prepare first index but only show after game start; still pick one so UI has data if needed
  currentIndex = pickRandomIndex();
  loadRound();
  updateTotalScore();
});

// Sidebar toggle behavior
const appEl = document.querySelector('.app');
const toggleBtn = document.getElementById('sidebarToggle');
function updateToggleIcon(){
  if(appEl.classList.contains('collapsed')) toggleBtn.textContent = '▶';
  else toggleBtn.textContent = '◀';
}
if(toggleBtn && appEl){
  toggleBtn.addEventListener('click', ()=>{
    appEl.classList.toggle('collapsed');
    updateToggleIcon();
    // Ensure map is resized after layout change
    setTimeout(()=> map.invalidateSize(), 220);
  });
}
updateToggleIcon();
</script>
</body>
</html>